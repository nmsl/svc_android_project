#include "type.h"
#include "main_data.h"
#include "svc_type.h"
#include "GetHttpStream.h"
#include "Read_h264.h"

#include <cpu-features.h>
#include <jni.h>
#include <android/log.h>
#include <android/bitmap.h>
#include <prof.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <semaphore.h>
#include <signal.h>

#define  LOG_TAG    "libsvc"
#define  LOGI(...)  __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)
#define  LOGE(...)  __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)

#define uchar unsigned char
#define ushort unsigned short
#define ulong unsigned long
#define uint unsigned int
#define prec_synchro int
#define stream unsigned char
#define image_type unsigned char
#define dpb_type unsigned char

//#define THREAD_NUM 3

typedef unsigned char byte; // Byte is a char
typedef unsigned short int word16; // 16-bit word is a short int
typedef unsigned int word32; // 32-bit word is an int

static void* pixels[64];
static AndroidBitmapInfo info;
static char* FILE_PATH;
static int LAYER_ID = 16;		// set defualt
static int MAX_LAYER_ID;		// for testing
static int TEMPORAL_ID;
static int Temporal_changed; 	// for testing~~~
static int Layer_changed;		// for testing too ~~
static int THREAD_NUM;
//static pthread_t ThreadList[THREAD_NUM];
static pthread_t* ThreadList;
static pthread_t request_thread;

static int i;
static int init = 0;

static int time_start, time_end, framecounter;
static int bitmapFilledCounter, bitmapFilledMax;
static int flagError;


void init_svc_vectors(SVC_VECTORS *svc);
void decode_init_vlc(VLC_TABLES *VLc);
void vector_main_init(MAIN_STRUCT_PF *pf);
//void readh264_init(int argc,char **argv);
void get_layer(int argc, char **argv, ConfigSVC *NumLayer);
void choose_layer(ConfigSVC *NumLayer);
void ParseFirstAU(int StreamSize, uchar *Buffer, ConfigSVC *StreamType);
int GetNalBytesAuSVC(uchar *data, stream *rbsp, int *NalInRbsp,
		ConfigSVC *StreamType, NALSTREAMER *NalSize, SPS *Sps, PPS *Pps);
void init_int(int *tab);
void init_mmo(int num_of_layers, MMO *mmo_stru);
void init_slice(SLICE *slice);
void init_pps(PPS *sps);
void init_sps(SPS *sps);
void InitListMmo(LIST_MMO *RefPicListL0);
void slice_header_svc(int NbLayers, const stream *data, SPS *sps_id,
		PPS *pps_id, int *entropy_coding_flag, W_TABLES *quantif,
		LIST_MMO *current_pic, SPS *sps, PPS *pps, int *position, SLICE *slice,
		MMO *mmo, LIST_MMO RefPicListL0[], LIST_MMO RefPicListL1[], NAL *nal,
		int *end_of_slice, int *ImgToDisplay, int *xsize, int *ysize,
		int *AddressPic, int *Crop);
void pic_parameter_set(stream *data, uchar *ao_slice_group_id, PPS *pps,
		SPS *sps, const int NalBytesInNalunit);
void decoderh264_init(const int pic_width, const int pic_height);
void Init_SDL(int edge, int frame_width, int frame_height);
void SDL_Display(int edge, int frame_width, int frame_height, unsigned char *Y,
		unsigned char *V, unsigned char *U);
void CloseSDLDisplay();
void ReadAuH264(const int nb_octets_to_read, uchar *buffer, int ReadnewBytes,
		int *nb_octet_already_read);
void NextNalDqId(ConfigSVC *Buffer, NAL *NAL);
void init_nal_struct(NAL *nal, unsigned char NumOfLayer);
void NalUnitSVC(stream *data_in, int *nal_unit_type, int *nal_ref_idc, NAL *Nal);
void init_int(int *tab);
void svc_calculate_dpb(const int total_memory, const int mv_memory,
		int nb_of_layers, MMO *mmo_struct, SPS *sps, NAL *Nal);
void sei_rbsp(stream *data, int NalInRbsp, SPS *sps, SEI *Sei);
void seq_parameter_set(stream *data, SPS *sps);
void FlushSVCFrame(SPS *sps, NAL *nal, MMO *mmo, int *address_pic, int *x_size,
		int *y_size, int *Crop, int *img_to_display);
void PrefixNalUnit(stream *data, int *NalinRbsp, NAL *nal, MMO *mmo, SPS *sps,
		int *EndOfSlice);
void subset_sps(stream *data, int * NalInRbsp, SPS *sps, NAL *nal);
void NalUnitHeader(const stream *data, int *pos, NAL *nal, int *EndOfSlice);
void slice_data_in_scalable_extension_cavlc(const int size_mb,
		const stream *ai_pcData, int * NalInRbsp, const int *ai_piPosition,
		const NAL *nal, const SPS *ai_pstSps, PPS *ai_pstPps,
		const VLC_TABLES *vlc, uchar *ai_slice_group_id, SLICE *aio_pstSlice,
		uchar *aio_tiMbToSliceGroupMap, uchar *aio_tiSlice_table,
		DATA *aio_tstTab_block, RESIDU *residu, int * aio_piEnd_of_slice);
void SliceCabac(const int size_mb, uchar *data, int *position,
		int *NalBytesInNalunit, const NAL *Nal, SPS *sps, PPS *pps,
		uchar *ai_slice_group_id, short *mv_cabac_l0, short *mv_cabac_l1,
		short *ref_cabac_l0, short *ref_cabac_l1, SLICE *slice,
		uchar *MbToSliceGroupMap, uchar *slice_table, DATA *Tab_block,
		RESIDU *picture_residu, int *end_of_slice);
void slice_base_layer_cavlc(const stream *ai_pcData, int * NalInRbsp,
		const int *ai_piPosition, const SPS *ai_pstSps, PPS *ai_pstPps,
		const VLC_TABLES *Vlc, uchar *ai_slice_group_id, LIST_MMO *Current_pic,
		LIST_MMO *RefListl1, NAL *Nal, SLICE *aio_pstSlice,
		uchar *aio_tiMbToSliceGroupMap, uchar *aio_tiSlice_table,
		DATA *aio_tstTab_block, RESIDU *picture_residu,
		int * aio_piEnd_of_slice, short *mv_io, short *mvl1_io, short *ref_io,
		short *refl1_io);
void slice_base_layer_cabac(uchar *data, int *position, int *NalBytesInNalunit,
		SPS *sps, PPS *pps, uchar *ai_slice_group_id, LIST_MMO *Current_pic,
		LIST_MMO *RefListl1, NAL *Nal, short *mv_cabac_l0, short *mv_cabac_l1,
		short *ref_cabac_l0, short *ref_cabac_l1, SLICE *slice,
		uchar *MbToSliceGroupMap, uchar *slice_table, DATA *Tab_block,
		RESIDU *picture_residu, int *end_of_slice, short *mvl0_io,
		short *mb_l1_io, short *refl0_io, short *refl1_io);
void Decode_P_avc(const SPS *ai_pstSps, const PPS *ai_pstPps,
		const SLICE *ai_pstSlice, const uchar *ai_tiSlice_table,
		const RESIDU *picture_residu, const STRUCT_PF *pf,
		const LIST_MMO *ai_pstRefPicListL0, const LIST_MMO *ai_pstCurrent_pic,
		W_TABLES *quantif_tab, NAL *Nal, short *aio_tiMv, short *aio_tiRef,
		uchar *aio_tucDpb_luma, uchar *aio_tucDpb_Cb, uchar *aio_tucDpb_Cr,
		short *Residu_Img, short *Residu_Cb, short *Residu_Cr);
void Decode_B_avc(SPS *ai_stSps, PPS *ai_stPps, SLICE *ai_stSlice,
		uchar *ai_tSlice_table, RESIDU *picture_residu,
		MAIN_STRUCT_PF *main_vector, LIST_MMO *ai_pRefPicListL0,
		LIST_MMO *ai_pRefPicListL1, LIST_MMO *ai_pCurrent_pic,
		W_TABLES *quantif, NAL *Nal, short *aio_tMv_l0, short *aio_tMv_l1,
		short *aio_tref_l0, short *aio_tref_l1, uchar *aio_tDpb_luma,
		uchar *aio_tDpb_Cb, uchar *aio_tDpb_Cr, short *Residu_img,
		short *Residu_Cb, short *Residu_Cr);
void Decode_I_avc(SPS *sps, PPS *pps, SLICE *slice, uchar *slice_table,
		RESIDU *picture_residu, STRUCT_PF *pf, W_TABLES *quantif_tab, NAL *Nal,
		uchar *image, uchar *image_Cb, uchar *image_Cr);
void FinishFrameSVC(const int NbMb, NAL *Nal, SPS *Sps, PPS *Pps,
		LIST_MMO *Current_pic, SLICE *Slice, int EndOfSlice, uchar *SliceTab,
		DATA *TabBlbock, RESIDU *Residu, short *MvL0, short *MvL1, short *RefL0,
		short *RefL1, int *Crop, int *ImgToDisplay, int *AdressPic, MMO *Mmo,
		unsigned char *RefY, unsigned char *RefU, unsigned char *RefV,
		int *xsize, int *ysize);
void Decode_P_svc(const int size, const SPS *ai_pstSps, const PPS *ai_pstPps,
		const SLICE *ai_pstSlice, const NAL *nal, const uchar *ai_tiSlice_table,
		const DATA *ai_tstTab_Block, RESIDU *residu, STRUCT_PF *baseline_vector,
		const LIST_MMO *ai_pstRefPicListL0, const LIST_MMO *ai_pstCurrent_pic,
		W_TABLES *quantif_tab, SVC_VECTORS *svc, short *px, short *py,
		short *Upsampling_tmp, short *xk16, short *xp16, short *yk16,
		short* yp16, short *aio_tiMv, short *aio_tiRef, uchar *aio_tucDpb_luma,
		uchar *aio_tucDpb_Cb, uchar *aio_tucDpb_Cr, short *Residu_Img,
		short *Residu_Cb, short *Residu_Cr);

void Decode_B_svc(const int size, const SPS *ai_pstSps, const PPS *ai_pstPps,
		const SLICE *ai_pstSlice, const NAL *nal, const uchar *ai_tiSlice_table,
		const DATA *ai_tstTab_Block, RESIDU *residu,
		MAIN_STRUCT_PF *baseline_vector, const LIST_MMO *ai_pstRefPicListL0,
		const LIST_MMO *ai_pstRefPicListL1, const LIST_MMO *ai_pstCurrent_pic,
		W_TABLES *quantif_tab, SVC_VECTORS *svc, short *px, short *py,
		short *Upsampling_tmp, short *k16, short *p16, short *yk16, short *yp16,
		short *aio_tiMv_l0, short *aio_tMv_l1, short *aio_tiRef_l0,
		short *aio_tiRef_l1, uchar *aio_tucDpb_luma, uchar *aio_tucDpb_Cb,
		uchar *aio_tucDpb_Cr, short *Residu_Img, short *Residu_Cb,
		short *Residu_Cr);
void Decode_I_svc(const int size, SPS *sps, PPS *pps, SLICE *slice, NAL *nal,
		uchar *slice_table, DATA *Block, RESIDU *residu, STRUCT_PF *vector,
		LIST_MMO *Current_pic, W_TABLES *quantif, unsigned char *aio_tucImage,
		unsigned char *aio_tucImage_Cb, unsigned char *aio_tucImage_Cr);
void extract_picture(int xsize, int ysize, int edge, int Crop,
		uchar *img_luma_in, uchar *img_Cb_in, uchar *img_Cr_in, int address_pic,
		uchar *img_luma_out, uchar *img_Cb_out, uchar *img_Cr_out);
int UserDefinedSearchFrameToDisplay(NAL *Nal, MMO *Mmo, int *x_size,
		int *y_size, int *Crop, int *ImgToDisplay, int *address_pic);

void toRGB565(byte yuvs[], int width, int height, byte rgbs[], int sw, int sh) {
	//the end of the luminance data
	const int lumEnd = width * height;
	//points to the next luminance value pair
	int lumPtr = 0;
	//points to the next chromiance value pair
	int chrPtr = lumEnd;
	//points to the next byte output pair of RGB565 value
	int outPtr = 0;
	//the end of the current luminance scanline
	int lineEnd = width;

	while (1) {
		//skip back to the start of the chromiance values when necessary
		if (lumPtr == lineEnd) {
			if (lumPtr == lumEnd)
				break; //we've reached the end
			//division here is a bit expensive, but's only done once per scanline
			chrPtr = lumEnd + ((lumPtr / width) >> 1) * (width >> 1);
			lineEnd += width;
			//to erase green bar
			outPtr -= 64;            //32*2
		}

		//read the luminance and chromiance values
		const int Y1 = yuvs[lumPtr++];
		const int Y2 = yuvs[lumPtr++];
		const int Cb = (yuvs[chrPtr]) - 128;
		const int Cr = (yuvs[chrPtr + width * height / 4]) - 128;
		chrPtr++;
		int R, G, B;
		const int deltaB = ((454 * Cb) >> 8);
		const int deltaG = ((88 * Cb + 183 * Cr) >> 8);
		const int deltaR = ((359 * Cr) >> 8);

		//generate first RGB components
		B = Y1 + deltaB;
		if (B < 0)
			B = 0;
		else if (B > 255)
			B = 255;

		G = Y1 - deltaG;
		if (G < 0)
			G = 0;
		else if (G > 255)
			G = 255;

		R = Y1 + deltaR;
		if (R < 0)
			R = 0;
		else if (R > 255)
			R = 255;
		//NOTE: this assume little-endian encoding
		rgbs[outPtr++] = (byte) (((G & 0x3c) << 3) | (B >> 3));
		rgbs[outPtr++] = (byte) ((R & 0xf8) | (G >> 5));

		//generate second RGB components
		B = Y2 + deltaB;
		if (B < 0)
			B = 0;
		else if (B > 255)
			B = 255;

		G = Y2 - deltaG;
		if (G < 0)
			G = 0;
		else if (G > 255)
			G = 255;

		R = Y2 + deltaR;
		if (R < 0)
			R = 0;
		else if (R > 255)
			R = 255;
		//NOTE: this assume little-endian encoding
		rgbs[outPtr++] = (byte) (((G & 0x3c) << 3) | (B >> 3));
		rgbs[outPtr++] = (byte) ((R & 0xf8) | (G >> 5));
	}
	//LOGE("rgb size %d, w %d, h %d",outPtr,width, height);
}

//Frame Structure
typedef struct {
	unsigned char* RGB;
} EachFrame;

//Frame Store for each Thread
typedef struct _FrameStore {
	int frameAllocated;
	int frameCounter;
	int displayCounter;
	int edge;
	int frameWidth, frameHeight;
	int fps;
	int IDRindex;
	int waitForDisplay;
	EachFrame frameList[100]; //hard code it, I don't want to realloc it, there is no vector in C...

	//do what member function doing in C++...
	void (*frameInit)(struct _FrameStore* this, EachFrame* newFrame);
	void (*frameDestory)(struct _FrameStore* this);
	void (*Display)(struct _FrameStore* this);
	void (*DisplaySingle)(struct _FrameStore* this);
	void (*fillFrame)(struct _FrameStore* this, unsigned char* Y,
			unsigned char* U, unsigned char* V);
	int (*isEmpty)(struct _FrameStore* this);
	void (*checkResolution)(struct _FrameStore* this);

} FrameStore;

//static FrameStore FrameStoreList[THREAD_NUM];
static FrameStore* FrameStoreList;

//Alloc YUV
void FrameStore_frameInit(struct _FrameStore* this, EachFrame* newFrame) {

	newFrame->RGB = (unsigned char*) malloc( sizeof(unsigned char) * this->frameWidth * this->frameHeight * 2 + 32 );
	if (newFrame->RGB == NULL) {
		LOGE("w %d, h %d", this->frameWidth, this->frameHeight);
		LOGE("Bear: malloc failed\n");
		exit(-1);
	}
}

//Display all GOP
void FrameStore_Display(struct _FrameStore* this) {
	int i;

	//start at the displayCounter
	for (i = this->displayCounter; i < this->frameCounter; ++i) {
		memcpy(pixels[bitmapFilledCounter++], this->frameList[i].RGB, this->frameWidth * this->frameHeight * 2);
		//free(this->frameList[i].RGB);
	}
	//reset all counter
	//this->frameAllocated = 0;
	this->frameCounter = 0;
	this->displayCounter = 0;
}

//This function is used to display only one frame
//It avoid to wait a long time until whole GOP is already decoded
//Thus, it can be played at the same time while decoding at low speed
void FrameStore_DisplaySingle(struct _FrameStore* this) {
//depreciated
	/*
	 //check exist frame to display
	 if(this->displayCounter==this->frameCounter)
	 return;
	 //send to display

	 //free memory after display
	 free(this->frameList[this->displayCounter].Y);
	 //free(this->frameList[this->displayCounter].U);
	 //free(this->frameList[this->displayCounter].V);
	 ++this->displayCounter;
	 */
}

//Insert YUV data to Frame Store
void FrameStore_fillFrame(struct _FrameStore* this, unsigned char* Y, unsigned char* U, unsigned char* V) {
	//alloc if all frame element are used
	//no use because now I always free frames after displayed
	//it will be used to avoid much alloc in the future
	if (this->frameCounter == this->frameAllocated) {
		this->frameList[0];
		this->frameInit(this, &(this->frameList[this->frameAllocated]));
		++this->frameAllocated;
	}
	toRGB565(Y, this->frameWidth + 32, this->frameHeight,
			(byte*) this->frameList[this->frameCounter].RGB,
			this->frameWidth + 32, this->frameHeight);
	++this->frameCounter;
	LOGE("TESTSEG : frameCounter = %d", this -> frameCounter);
}

//Flush all frames
void FrameStore_frameDestory(struct _FrameStore* this) {
	//alloc if all frame element are used
	//no use because now I always free frames after displayed
	//it will be used to avoid much alloc in the future
	int i;
	for (i = 0; i < this->frameAllocated; ++i) {
		free((byte*) this->frameList[i].RGB);
		this->frameList[i].RGB = NULL;
	}
	this->frameCounter = 0;
	this->frameAllocated = 0;
	LOGE("finish destory");
}

//Check there is no frame in Frame Store
int FrameStore_isEmpty(struct _FrameStore* this) {
	if (this->frameCounter > 0)
		return 0;
	return 1;
}

void FrameStore_checkResolution(struct _FrameStore* this) {
	if (this->frameWidth != info.width || this->frameHeight != info.height)
		flagError = 1;
}

//It's constructor like C++
void FrameStoreConstructor(struct _FrameStore* this) {
	this->frameAllocated = 0;
	this->frameCounter = 0;
	this->displayCounter = 0;
	this->edge = 16;
	this->frameWidth = 0;
	this->frameHeight = 0;
	this->fps = 20;
	this->IDRindex = 0;
	this->waitForDisplay = 0;
	this->frameInit = FrameStore_frameInit;
	this->frameDestory = FrameStore_frameDestory;
	this->Display = FrameStore_Display;
	this->DisplaySingle = FrameStore_DisplaySingle;
	this->fillFrame = FrameStore_fillFrame;
	this->isEmpty = FrameStore_isEmpty;
	this->checkResolution = FrameStore_checkResolution;
}
void FrameStoreDeConstructor(struct _FrameStore* this) {
	for (; --this->frameAllocated >= 0;) {
		free(this->frameList[this->frameAllocated].RGB);
	}
}

typedef struct {
	image_type Display_1_Extract_1_Image_Y_o[3279368];
	image_type Display_1_Extract_Image_Y_o[3279368];
	NAL DqIdNextNal_Nal_o[1];
	NALSTREAMER GetNalBytesAu_NalStreamer[1];
	PPS GetNalBytesAu_PPS[255];
	SPS GetNalBytesAu_SPS[32];
	ConfigSVC GetNalBytesAu_StreamType[1];
	int GetNalBytesAu_rbsp_o_size[1];
	stream GetNalBytesAu_rbsp_o[1622016];
	uchar ReadAU_DataFile_o[1622016];
	int ReadAU_ReadBytes[1];
	int ReadAU_pos_o[1];
	short decoder_svc_MvBuffer_1_Mv[11489280];
	short decoder_svc_MvBuffer_1_Ref[5744640];
	short decoder_svc_MvBuffer_Mv[11489280];
	short decoder_svc_MvBuffer_Ref[5744640];
	int decoder_svc_NalUnit_NalRefIdc_io[1];
	int decoder_svc_NalUnit_NalUnitType_io[1];
	int decoder_svc_Nal_Compute_NalDecodingProcess_Set_Pos_Pos[1];
	int decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_entropy_coding_flag[1];
	PPS decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id[1];
	W_TABLES decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_quantif[1];
	SPS decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id[1];
	int decoder_svc_Nal_Compute_NalDecodingProcess_Slice_type_SliceType_o[1];
	short decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_mv_cabac_l0_o[261120];
	short decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_mv_cabac_l1_o[261120];
	short decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_ref_cabac_l0_o[32640];
	short decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_ref_cabac_l1_o[32640];
	int decoder_svc_Nal_Compute_SetPos_Pos[1];
	int decoder_svc_Nal_Compute_SliceHeaderIDR_entropy_coding_flag[1];
	PPS decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id[1];
	W_TABLES decoder_svc_Nal_Compute_SliceHeaderIDR_quantif[1];
	SPS decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id[1];
	int decoder_svc_Nal_Compute_nal_unit_header_svc_ext_20_pos_o[1];
	SEI decoder_svc_Nal_Compute_sei_rbsp_Sei[1];
	int decoder_svc_Nal_Compute_seq_parameter_set_IdOfsps_o[1];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_Upsampling_tmp[2088960];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_px[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_py[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_xk16[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_xp16[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_yk16[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_yp16[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_Upsampling_tmp[2088960];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_px[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_py[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_xk16[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_xp16[1920];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_yk16[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_yp16[1088];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_mv_cabac_l0_o[261120];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_mv_cabac_l1_o[261120];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_ref_cabac_l0_o[32640];
	short decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_ref_cabac_l1_o[32640];
	int decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_type_SliceType_o[1];
	int decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_entropy_coding_flag[1];
	PPS decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_pps_id[1];
	W_TABLES decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_quantif[1];
	SPS decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_sps_id[1];
	short decoder_svc_Nal_Compute_slice_layer_main_CABAC_mv_cabac_l0_o[261120];
	short decoder_svc_Nal_Compute_slice_layer_main_CABAC_mv_cabac_l1_o[261120];
	short decoder_svc_Nal_Compute_slice_layer_main_CABAC_ref_cabac_l0_o[32640];
	short decoder_svc_Nal_Compute_slice_layer_main_CABAC_ref_cabac_l1_o[32640];
	uchar decoder_svc_PictureBuffer_RefU[12570880];
	uchar decoder_svc_PictureBuffer_RefV[12570880];
	uchar decoder_svc_PictureBuffer_RefY[50283520];
	short decoder_svc_ResiduBuffer_RefU[2186240];
	short decoder_svc_ResiduBuffer_RefV[2186240];
	short decoder_svc_ResiduBuffer_RefY[8744960];
	DATA decoder_svc_Residu_Block[8160];
	LIST_MMO decoder_svc_Residu_Current_pic[1];
	uchar decoder_svc_Residu_MbToSliceGroupMap[8160];
	MMO decoder_svc_Residu_Mmo[1];
	PPS decoder_svc_Residu_PPS[255];
	LIST_MMO decoder_svc_Residu_RefL0[16];
	LIST_MMO decoder_svc_Residu_RefL1[16];
	RESIDU decoder_svc_Residu_Residu[32640];
	SPS decoder_svc_Residu_SPS[32];
	SLICE decoder_svc_Residu_Slice[1];
	uchar decoder_svc_Residu_SliceGroupId[8160];
	uchar decoder_svc_Residu_SliceTab[8160];
	SVC_VECTORS decoder_svc_Svc_Vectors_PC_Svc_Vectors[1];
	int decoder_svc_VideoParameter_Crop[1];
	int decoder_svc_VideoParameter_EndOfSlice[1];
	int decoder_svc_VideoParameter_ImgToDisplay[1];
	int decoder_svc_VideoParameter_address_pic_o[1];
	int decoder_svc_VideoParameter_xsize_o[1];
	int decoder_svc_VideoParameter_ysize_o[1];
	VLC_TABLES decoder_svc_VlcTab_PC_o[1];
	MAIN_STRUCT_PF decoder_svc_slice_main_vector_PC_Main_vector_o[1];
	int iFrame;
	int EndOfStream;
} SVCinfo;

//static SVCinfo SVCinfoList[THREAD_NUM];
static int getMinBytes = 1622016;	// default 1622016, 819808 for test
static SVCinfo* SVCinfoList;

// testing sync.
static pthread_mutex_t TestRequestMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t startDecode = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t CanPlayCond = PTHREAD_COND_INITIALIZER;

static pthread_mutex_t DirtyMutex = PTHREAD_MUTEX_INITIALIZER;				// it just work
static pthread_mutex_t CurrentDisplayMutex = PTHREAD_MUTEX_INITIALIZER;		//
static pthread_mutex_t FrameBufferMutex = PTHREAD_MUTEX_INITIALIZER;		// write to frame buffer
static pthread_cond_t CurrentDisplayCond = PTHREAD_COND_INITIALIZER;
static pthread_cond_t FrameBufferCond = PTHREAD_COND_INITIALIZER;
static int CurrentDisplay;

void retrieveFrame(int threadID) {
	if (SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay[0] == 1
			|| SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay[0] == 2)
	{

		int XDIM
			= ((int *) SVCinfoList[threadID].Display_1_Extract_Image_Y_o)[0]
			= *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;

		int YDIM
			= ((int *) SVCinfoList[threadID].Display_1_Extract_Image_Y_o)[1]
		    = *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;

		uchar *Y = SVCinfoList[threadID].Display_1_Extract_Image_Y_o + 8;
		uchar *U = Y + (XDIM + 32) * YDIM;
		uchar *V = U + (XDIM + 32) * YDIM / 4;

		extract_picture(XDIM, YDIM, 16,
				SVCinfoList[threadID].decoder_svc_VideoParameter_Crop[0],
				SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
				SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
				SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
				SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o[0],
				Y, U, V);

		//fill data to frame store
		LOGE("Thread %d: w=%d * nw=%d\n",
				threadID, FrameStoreList[threadID].frameWidth, *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o);
		FrameStoreList[threadID].frameWidth = *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;
		FrameStoreList[threadID].frameHeight = *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;
		FrameStoreList[threadID].fillFrame(&FrameStoreList[threadID], Y, U, V);
	}
}
/*
 static char* StreamBufferPtr;
 static int*  FileSizePtr;
 static int* StreamBufferPosPtr;*/

/*
 * Get segments from HTTP server
 * each segment has eight GOPs
 *
 * test_0.264 	has 0 <= LayrID <= 16, 1 <= Temporal <= 3,
 * 				GOP from 0 to 7
 * test_1.264 	has 0 <= LayrID <= 32, 1 <= Temporal <= 3,
 * 				GOP from 8 to 15
 * test_1_2.264 has 0 <= LayrID <= 16, 1 <= Temporal <= 3,
 * 				GOP from 8 to 15
 */
void streamFromHttp(int *number) {
	LOGE("TESTSEG : in streamFromHTTP()");
	extern char* StreamBuffer;
	extern int file_size;
	extern int StreamBufferPos;
//	extern int currentBufferPos;

	int seqSize;
	char *seqBuf = (char*) malloc(sizeof(char) * 10000000);

	// hard code temporary
	// dump all 264 streams
	// LOGE("Ready to stream\n");

	/** segment 1, can request many times **/
//	if (LAYER_ID == 32) {
		GetHttpStream("http://140.114.79.80/temp.264", seqBuf, &seqSize);
		LOGE("TEST264 : get temp.264");
		MAX_LAYER_ID = 32;
//	}
//	else if (LAYER_ID == 16) {
//		GetHttpStream("http://140.114.79.80/temp.264", seqBuf, &seqSize);
//		LOGE("TEST264 : get test_1.264.264");
//		MAX_LAYER_ID = 16;
//	}
	pthread_mutex_lock(&FrameBufferMutex);
	memcpy(&StreamBuffer[StreamBufferPos], seqBuf, seqSize * sizeof(char));
	StreamBufferPos += seqSize;
	pthread_mutex_unlock(&FrameBufferMutex);

	LOGE("TEST264 : total download byte = %d at %d segment", StreamBufferPos, *number);
//	LOGE("TEST264 : currentPlay byte = %d at %d segment", currentBufferPos, *number);
//	LOGE("TEST264 : difference byte = %d at %d segment", (StreamBufferPos - currentBufferPos), *number);

	/** segment 2, not available **/
//	GetHttpStream("http://140.114.79.80/test_t2.264", seqBuf, &seqSize);
//	memcpy(&StreamBuffer[StreamBufferPos], seqBuf, seqSize * sizeof(char));
//	StreamBufferPos += seqSize;

	LOGE("*****Get Stream %d %d\n", file_size, StreamBufferPos);
}

int displayTimes;
void* getStreams() {
//	pthread_mutex_lock(&TestRequestMutex);

	for (displayTimes = 1; displayTimes <= 3; displayTimes++) {
		streamFromHttp(&displayTimes);
		LOGE("TESTSEG : before unlock startDecode in getStream()");
//		pthread_mutex_lock(&startDecode);
		pthread_cond_broadcast(&CanPlayCond);
//		pthread_mutex_unlock(&startDecode);
		LOGE("TESTSEG : after unlock startDecode in getStream()");
	}

//	pthread_mutex_unlock(&TestRequestMutex);

}

// Bear for stack size
pthread_attr_t attr;

void fileStreamInit() {
//	pthread_mutex_lock(&TestRequestMutex);
	LOGE("TESTSEG : in fileStreamInit()");

	extern char* StreamBuffer;
	extern int file_size;
	extern int StreamBufferPos;
//	extern int currentBufferPos;

	file_size = 20971520;	// 20MB
	StreamBufferPos = 0;
	StreamBuffer = (char*) malloc(file_size * sizeof(char));

	//hard code temporary
	//it should read from manifest file

	/*
	 StreamBufferPtr = getStreamBufferPtr();
	 FileSizePtr = getFileSizePtr();
	 StreamBufferPosPtr = getStreamBufferPosPtr();
	 */

	int seqSize;
	char *seqBuf = (char*) malloc(sizeof(char) * 10000000);

	/** segment 0, only can get once **/
	GetHttpStream("http://140.114.79.80/test_0.264", seqBuf, &seqSize);
	memcpy(&StreamBuffer[StreamBufferPos], seqBuf, seqSize * sizeof(char));
	StreamBufferPos += seqSize;
	MAX_LAYER_ID = 16;
	LOGE("TEST264 : get test_0.264");
	LOGE("TEST264 : total download byte = %d at 0 segment", StreamBufferPos);
//	LOGE("TEST264 : currentPlay byte = %d at 0 segment", currentBufferPos);
//	LOGE("TEST264 : difference byte = %d at 0 segment", (StreamBufferPos - currentBufferPos));

//	pthread_mutex_unlock(&TestRequestMutex);

	pthread_attr_init( &attr );
	pthread_create( &request_thread, &attr, (void*)getStreams, NULL);

//	streamFromHttp();
}

void initialize(int threadID) {
	__android_log_print(ANDROID_LOG_ERROR, "test", "init: %d", time(NULL));

	//~ FILE* yfile = fopen("/sdcard/f1.yuv","w+");

	int argc = 7;
	char **argv = (char **) malloc(sizeof(char *) * 7);
	argv[1] = "-h264";
	argv[2] = FILE_PATH;
	//argv[2] = "/sdcard/doc-reality.264";
	//argv[2] = "/sdcard/video_3.264";
	//argv[2] = "/sdcard/doc-reality-short.264";
	argv[3] = "-layer";
	argv[4] = (char *) malloc(sizeof(char) * 5);
	sprintf(argv[4], "%d", LAYER_ID);
	argv[5] = "-tempId";
	argv[6] = (char *) malloc(sizeof(char) * 5);
	sprintf(argv[6], "%d", TEMPORAL_ID);

	init_svc_vectors(SVCinfoList[threadID].decoder_svc_Svc_Vectors_PC_Svc_Vectors);
	decode_init_vlc(SVCinfoList[threadID].decoder_svc_VlcTab_PC_o);
	vector_main_init(SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o);
	*SVCinfoList[threadID].ReadAU_ReadBytes = 1622016;
	readh264_init(argc, argv);    //comment out with stream buffer
	get_layer(argc, argv, SVCinfoList[threadID].GetNalBytesAu_StreamType);
	ParseFirstAU(1622016, SVCinfoList[threadID].ReadAU_DataFile_o, SVCinfoList[threadID].GetNalBytesAu_StreamType);
	init_nal_struct(SVCinfoList[threadID].DqIdNextNal_Nal_o, 4);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o);
	init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_Crop);
	init_slice(SVCinfoList[threadID].decoder_svc_Residu_Slice);
	init_sps(SVCinfoList[threadID].decoder_svc_Residu_SPS);
	init_pps(SVCinfoList[threadID].decoder_svc_Residu_PPS);
	InitListMmo(SVCinfoList[threadID].decoder_svc_Residu_RefL0);
	InitListMmo(SVCinfoList[threadID].decoder_svc_Residu_RefL1);
	InitListMmo(SVCinfoList[threadID].decoder_svc_Residu_Current_pic);
	init_mmo(4, SVCinfoList[threadID].decoder_svc_Residu_Mmo);
	SVCinfoList[threadID].decoder_svc_Residu_Current_pic->frame_num += threadID;
	SVCinfoList[threadID].iFrame = -1;
	SVCinfoList[threadID].EndOfStream = 0;
	decoderh264_init(1920, 1088);
}

static int ThreadFinishSignal;
// static sem_t ReturnSem;

void* Thread_Decoding(void *argu) {
	LOGE("TESTSEG : wait for unlock in *Thread_decoding()");
	pthread_mutex_lock(&startDecode);
	pthread_cond_wait(&CanPlayCond, &startDecode);
	pthread_mutex_unlock(&startDecode);
	LOGE("TESTSEG : start decoding in *Thread_decoding()");


	// Get my thread ID
	int threadID = (int) argu;

	// Bear, play with stack size
	size_t mystacksize;
	pthread_attr_getstacksize(&attr, &mystacksize);
	LOGE("Thread %d: stack size = %li bytes\n", threadID, mystacksize);

	int isFinished = 0;

	//exit when already reach EOF and played
//	if(SVCinfoList[threadID].EndOfStream && FrameStoreList[threadID].isEmpty(&FrameStoreList[threadID])==0)
//		return NULL;

	for (; !isFinished; ) {		// why not use while ???
		if (SVCinfoList[threadID].EndOfStream)
			return NULL;

		pthread_mutex_lock(&DirtyMutex); // Bear

		ReadAuH264(1622016, SVCinfoList[threadID].ReadAU_DataFile_o,
				SVCinfoList[threadID].ReadAU_ReadBytes[0],
				SVCinfoList[threadID].ReadAU_pos_o);
		//choose_layer(SVCinfoList[threadID].GetNalBytesAu_StreamType);
		//SVCinfoList[threadID].GetNalBytesAu_StreamType -> SetLayer = 2;
		//SVCinfoList[threadID].GetNalBytesAu_StreamType -> TemporalCom = 0;

		SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size[0] = GetNalBytesAuSVC(
				SVCinfoList[threadID].ReadAU_DataFile_o,
				SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
				SVCinfoList[threadID].ReadAU_ReadBytes,
				SVCinfoList[threadID].GetNalBytesAu_StreamType,
				SVCinfoList[threadID].GetNalBytesAu_NalStreamer,
				SVCinfoList[threadID].GetNalBytesAu_SPS,
				SVCinfoList[threadID].GetNalBytesAu_PPS);

		NextNalDqId(SVCinfoList[threadID].GetNalBytesAu_StreamType,
				SVCinfoList[threadID].DqIdNextNal_Nal_o);

		NalUnitSVC(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
				SVCinfoList[threadID].decoder_svc_NalUnit_NalUnitType_io,
				SVCinfoList[threadID].decoder_svc_NalUnit_NalRefIdc_io,
				SVCinfoList[threadID].DqIdNextNal_Nal_o);

		init_int(SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay);

		pthread_mutex_unlock(&DirtyMutex); // Bear

		if (SVCinfoList[threadID].decoder_svc_NalUnit_NalUnitType_io[0] == 11) {
			LOGE("!!!!!!!!!!!!!!!!!!!!!!!!!! %d", threadID);
			SVCinfoList[threadID].EndOfStream = 1;
			//sem_post(&ReturnSem);
			return NULL;
		}

		// Type IDR-frame or End of stream
		if (SVCinfoList[threadID].decoder_svc_NalUnit_NalUnitType_io[0] == 5
				|| SVCinfoList[threadID].decoder_svc_NalUnit_NalUnitType_io[0] == 11
				|| SVCinfoList[threadID].EndOfStream) {

			// increase IDR-Num
			SVCinfoList[threadID].iFrame++;
//			LOGE("TESTSEG : thread %d increase iFrame to %d", threadID, SVCinfoList[threadID].iFrame);

			// I have previous frames want to Display
			if (FrameStoreList[threadID].isEmpty(&FrameStoreList[threadID]) == 0)
			{
				// retrieve all treasure from buffer
				if (!FrameStoreList[threadID].waitForDisplay)
				{
					while ( UserDefinedSearchFrameToDisplay(
							SVCinfoList[threadID].DqIdNextNal_Nal_o,
							SVCinfoList[threadID].decoder_svc_Residu_Mmo,
							SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
							SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o,
							SVCinfoList[threadID].decoder_svc_VideoParameter_Crop,
							SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
							SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o)
							== 0 )
					{
						retrieveFrame(threadID);
					}
				}

				LOGE("TESTSEG : Thread %d, ready to access display, frameCounter %d, CurrentDisplay %d, IDRindex %d",
						threadID, FrameStoreList[threadID].frameCounter, CurrentDisplay, FrameStoreList[threadID].IDRindex);

				// Critical region to access CurrentDisplay
				pthread_mutex_lock(&CurrentDisplayMutex);
                LOGE("Thread %d, run into critical region", threadID);
				int isFinishDisplay = 0;

                while (!isFinishDisplay) {
                    LOGE("Thread %d, begin loop", threadID);

                    if ( (CurrentDisplay < FrameStoreList[threadID].IDRindex) && (CurrentDisplay % THREAD_NUM == threadID) ) {
                        //++CurrentDisplay;
                        LOGE("TESTSEG : Thread %d, skip IDR %d", threadID, CurrentDisplay);
                        pthread_mutex_lock( &FrameBufferMutex );
                        // XDDD, why need to lock ??
                        pthread_mutex_unlock( &FrameBufferMutex );
                        pthread_cond_broadcast( &FrameBufferCond );
                        // sem_post(&ReturnSem);
                    }
                    else if(CurrentDisplay == FrameStoreList[threadID].IDRindex) {
						// check resource
						FrameStoreList[threadID].checkResolution(&FrameStoreList[threadID]);

                        pthread_mutex_lock(&FrameBufferMutex);		// lock

						if(!flagError) {
							// display~~~
							LOGE("TESTSEG : Thread %d, display with %d", threadID, FrameStoreList[threadID].IDRindex);
							FrameStoreList[threadID].Display(&FrameStoreList[threadID]);
							LOGE("TESTSEG : Thread %d, display finished, displayCounter %d", threadID, FrameStoreList[threadID].displayCounter);
							isFinishDisplay = 1;
						}
						else
							LOGE("ERROR~~%d",threadID);

						pthread_mutex_unlock(&FrameBufferMutex);	// unlcok

				        LOGE("Thread %d, post", threadID);
				        pthread_cond_broadcast(&FrameBufferCond);
				        //sem_post(&ReturnSem);
				    }

                    if(!isFinishDisplay){
                        // block until next signal while I'm fast!!
                        LOGE("Thread %d, blocked", threadID);
                    	pthread_cond_wait(&CurrentDisplayCond, &CurrentDisplayMutex);
                    }

                    if(SVCinfoList[threadID].EndOfStream)
                    	return NULL;
                }

                pthread_mutex_unlock(&CurrentDisplayMutex);
				//LOGE("Thread %d, leave access display, CurDisplay %d", threadID,CurrentDisplay);
			} // End check whether FrameStoreList is empty

			//set IDRindex
			if (SVCinfoList[threadID].iFrame != -1 && SVCinfoList[threadID].iFrame % THREAD_NUM == threadID) {
				FrameStoreList[threadID].IDRindex = SVCinfoList[threadID].iFrame;
				//LOGE("Thread %d, reset iFrame data to %d", threadID, FrameStoreList[threadID].IDRindex);
			}

			// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// test
			// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			/** auto setting **/
			// Temporal
//			if (SVCinfoList[threadID].iFrame == 5)
//			{
//				TEMPORAL_ID = 32;
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalId = TEMPORAL_ID;
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 2; //set specific temporal ID
//			}
//			else
//			{
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 0;
//			}

			// Layer
			LOGE("TEST264 : frame Number = %d", SVCinfoList[threadID].iFrame);
//			if (SVCinfoList[threadID].iFrame == 10) {
//				LAYER_ID = 32;
//				FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = LAYER_ID;
//			}
//			else if (SVCinfoList[threadID].iFrame == 17) {
//				LAYER_ID = 16;
//				FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = LAYER_ID;
//			}
//			else {
//				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 0;
//			}


//			if (Layer_changed == 1) {
//				if(LAYER_ID <= MAX_LAYER_ID) {
//					FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//					SVCinfoList[threadID].GetNalBytesAu_StreamType -> SetLayer = LAYER_ID;
//				}
//				else{
//					LAYER_ID = 16;
//					FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//					SVCinfoList[threadID].GetNalBytesAu_StreamType -> SetLayer = LAYER_ID;
//				}
//			}
//			else {
//				SVCinfoList[threadID].GetNalBytesAu_StreamType -> TemporalCom = 0;
//			}

//			if (SVCinfoList[threadID].iFrame >= 9) {
//				if (SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayr != LAYER_ID) {
//					FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//					SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = LAYER_ID;
//				}
//				else {
//					SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 0;
//				}
//			}


			// set temporal ID
			if (Temporal_changed == 1) {
				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalId = TEMPORAL_ID;
				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 2; //set specific temporal ID
				Temporal_changed = 0;
			}
			else {
				SVCinfoList[threadID].GetNalBytesAu_StreamType->TemporalCom = 0;
			}


			// set layer ID
//			if (Layer_changed == 1)
//			{
//				Layer_changed = 0;
//				FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//				if ( SVCinfoList[threadID].iFrame >= 9 && LAYER_ID == 32 )
//				{
//					SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = 32;
//				}
//				else
//				{
//					SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = 16;
//				}
//			}

//			LOGE("TEST264 : Layer ID = %d, Temporal ID = %d", LAYER_ID, TEMPORAL_ID);

//			FrameStoreList[threadID].frameDestory(&FrameStoreList[threadID]);
//			SVCinfoList[threadID].GetNalBytesAu_StreamType->SetLayer = LAYER_ID;

			// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// end test
			// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//LOGE("Thread %d, leave IDR proc", threadID);
		}

		//------------------------------------------------Nal Unit Type---------------------------------------------------------------
		switch (SVCinfoList[threadID].decoder_svc_NalUnit_NalUnitType_io[0]) {

		case 1: {	// non-IDR
			if (SVCinfoList[threadID].iFrame % THREAD_NUM != threadID)
				break;  // not my job
			//LOGE("Thread %d, case 1", threadID);
			*SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Set_Pos_Pos = 8;
			slice_header_svc(4, SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_entropy_coding_flag,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_quantif,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].decoder_svc_Residu_PPS,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Set_Pos_Pos,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_Residu_RefL0,
					SVCinfoList[threadID].decoder_svc_Residu_RefL1,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop);

			//printf("Bear A1: frame_num = %d, poc = %d\n", SVCinfoList[threadID].decoder_svc_Residu_Current_pic->frame_num, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->poc);

			//------------------------------------------------entropy_coding_mode_flag---------------------------------------------------------------
			switch (SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_entropy_coding_flag[0]) {

			case 0: {	//Exp-Golomb coded
				//LOGE("Thread %d, case 1.0", threadID);
				slice_base_layer_cavlc(
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Set_Pos_Pos,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
						SVCinfoList[threadID].decoder_svc_VlcTab_PC_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref);
				break;
			}

			case 1: {	//CABAC
				//LOGE("Thread %d, case 1.1", threadID);
				slice_base_layer_cabac(
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Set_Pos_Pos,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_mv_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_mv_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_ref_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_slice_layer_CABAC_ref_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref);
				break;
			}
			} // End entropy_coding_mode_flag

			//------------------------------------------------Slice Type---------------------------------------------------------------
			*SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Slice_type_SliceType_o = SVCinfoList[threadID].decoder_svc_Residu_Slice[0].slice_type;
			switch (SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_Slice_type_SliceType_o[0]) {

			case 0: {	//P slice
				//LOGE("Thread %d, case 1.2", threadID);
				Decode_P_avc(
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o->baseline_vectors,
						SVCinfoList[threadID].decoder_svc_Residu_RefL0,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_quantif,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						&SVCinfoList[threadID].decoder_svc_MvBuffer_Mv[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MvMemoryAddress],
						&SVCinfoList[threadID].decoder_svc_MvBuffer_Ref[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MvMemoryAddress >> 1],
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefV);
				break;
			}

			case 1: {	//B slice
				//LOGE("Thread %d, case 1.3", threadID);
				Decode_B_avc(
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o,
						SVCinfoList[threadID].decoder_svc_Residu_RefL0,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_quantif,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefV);
				break;
			}

			case 2: {	//I slice
				//LOGE("Thread %d, case 1.4", threadID);
				Decode_I_avc(
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o->baseline_vectors,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_quantif,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress],
						&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress >> 2],
						&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress >> 2]);
				break;
			}
			} // End slice type

			FinishFrameSVC(1920 * 1088 / 256,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_NalDecodingProcess_SliceHeader_pps_id,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice[0],
					SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
					SVCinfoList[threadID].decoder_svc_Residu_Block,
					SVCinfoList[threadID].decoder_svc_Residu_Residu,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o);
			break;
		} // End Nal Unit Type case 1

		case 5: {  // Indicates a IDR-frame!
			//LOGE("Thread %d, case 5", threadID);
			if (SVCinfoList[threadID].iFrame % THREAD_NUM != threadID)
				break;  // not my job

			svc_calculate_dpb((2186240 * (10 + 10 + 4 - 1)),
					(1920 * 1088 / 8 * 4 * (10 + 1)), 4,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].DqIdNextNal_Nal_o);

			*SVCinfoList[threadID].decoder_svc_Nal_Compute_SetPos_Pos = 8;

			slice_header_svc(4, SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_entropy_coding_flag,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_quantif,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].decoder_svc_Residu_PPS,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SetPos_Pos,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_Residu_RefL0,
					SVCinfoList[threadID].decoder_svc_Residu_RefL1,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop);
			//printf("Bear A2: frame_num = %d, poc = %d\n", SVCinfoList[threadID].decoder_svc_Residu_Current_pic->frame_num, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->poc);

			//------------------------------------------------entropy_coding_mode_flag---------------------------------------------------------------
			switch (SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_entropy_coding_flag[0]) {

			case 0: {
				//LOGE("Thread %d, case 5.0", threadID);
				slice_base_layer_cavlc(
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SetPos_Pos,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id,
						SVCinfoList[threadID].decoder_svc_VlcTab_PC_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref);
				break;
			}

			case 1: {
				//LOGE("Thread %d, case 5.1", threadID);
				slice_base_layer_cabac(
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SetPos_Pos,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_main_CABAC_mv_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_main_CABAC_mv_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_main_CABAC_ref_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_main_CABAC_ref_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref);
				break;
			}
			}

			//------------------------------------------------Slice Type---------------------------------------------------------------
			//I slice
			//LOGE("Thread %d, case 5.2", threadID);
			Decode_I_avc(
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
					SVCinfoList[threadID].decoder_svc_Residu_Residu,
					SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o->baseline_vectors,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_quantif,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress],
					&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress >> 2],
					&SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV[SVCinfoList[threadID].decoder_svc_Residu_Current_pic->MemoryAddress >> 2]);

			FinishFrameSVC(1920 * 1088 / 256,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_SliceHeaderIDR_pps_id,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice[0],
					SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
					SVCinfoList[threadID].decoder_svc_Residu_Block,
					SVCinfoList[threadID].decoder_svc_Residu_Residu,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o);
			break;
		} // End Nal Unit Type case 5

		case 6: {	//Supplemental enhancement information
			//LOGE("Thread %d, case 6", threadID);
			pthread_mutex_lock(&DirtyMutex);	// Bear
			sei_rbsp(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size[0],
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_sei_rbsp_Sei);
			pthread_mutex_unlock(&DirtyMutex);	// Bear
			break;
		}

		case 7: {	//Sequence parameter set
			//LOGE("Thread %d, case 7", threadID);
			pthread_mutex_lock(&DirtyMutex);	// Bear
			seq_parameter_set(SVCinfoList[threadID].GetNalBytesAu_rbsp_o, SVCinfoList[threadID].decoder_svc_Residu_SPS);
			pthread_mutex_unlock(&DirtyMutex);	// Bear
			break;
		}

		case 8: {	//Picture parameter set
			//LOGE("Thread %d, case 8", threadID);
			pthread_mutex_lock(&DirtyMutex);	// Bear
			pic_parameter_set(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
					SVCinfoList[threadID].decoder_svc_Residu_PPS,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size[0]);
			pthread_mutex_unlock(&DirtyMutex);	// Bear
			break;
		}

		case 9: {
			//LOGE("Thread %d, case 9", threadID);
			//printf("Damn great!\n");
			//exit(0);
			break;
		}

		case 11: {  // Indicates the end of video..
			LOGE("Thread %d, case 11", threadID);
			pthread_mutex_lock(&DirtyMutex); // Bear
			FlushSVCFrame(SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o);
			pthread_mutex_unlock(&DirtyMutex); // Bear
			isFinished = 1;
			SVCinfoList[threadID].EndOfStream = 1;
			//sem_post(&ReturnSem);
			return NULL;
			break;
		}

		case 14: {	//Prefix NAL unit in scalable extension
			//LOGE("Thread %d, case 14", threadID);
			pthread_mutex_lock(&DirtyMutex); // Bear
			PrefixNalUnit(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice);
			pthread_mutex_unlock(&DirtyMutex); // Bear
			break;
		}

		case 15: {	//Subset sequence parameter set
			//LOGE("Thread %d, case 15", threadID);
			pthread_mutex_lock(&DirtyMutex); // Bear
			subset_sps(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].DqIdNextNal_Nal_o);
			pthread_mutex_unlock(&DirtyMutex); // Bear
			break;
		}

		case 20: {	//Coded slice in scalable extension
			//LOGE("Thread %d, case 20", threadID);
			if (SVCinfoList[threadID].iFrame % THREAD_NUM != threadID)
				break;  // not my job

			NalUnitHeader(SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_nal_unit_header_svc_ext_20_pos_o,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice);

			slice_header_svc(4, SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_pps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_entropy_coding_flag,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_quantif,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_SPS,
					SVCinfoList[threadID].decoder_svc_Residu_PPS,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_nal_unit_header_svc_ext_20_pos_o,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_Residu_RefL0,
					SVCinfoList[threadID].decoder_svc_Residu_RefL1,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop);
			//printf("ThreadID = %d A3: frame_num = %d, poc = %d\n",threadID, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->frame_num, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->poc);

			switch (SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_entropy_coding_flag[0]) {

			case 0: {
				//LOGE("Thread %d, case 20.0", threadID);
				slice_data_in_scalable_extension_cavlc(1920 * 1088 / 256,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_nal_unit_header_svc_ext_20_pos_o,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_pps_id,
						SVCinfoList[threadID].decoder_svc_VlcTab_PC_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice);
				break;
			}

			case 1: {
				//LOGE("Thread %d, case 20.1", threadID);
				SliceCabac(1920 * 1088 / 256,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o,
						SVCinfoList[threadID].GetNalBytesAu_rbsp_o_size,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_nal_unit_header_svc_ext_20_pos_o,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_sps_id,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_pps_id,
						SVCinfoList[threadID].decoder_svc_Residu_SliceGroupId,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_mv_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_mv_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_ref_cabac_l0_o,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_Layer_SliceLayerCabac_ref_cabac_l1_o,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].decoder_svc_Residu_MbToSliceGroupMap,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice);
				break;
			}
			}

			*SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_type_SliceType_o = SVCinfoList[threadID].decoder_svc_Residu_Slice[0].slice_type;
			switch (SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Slice_type_SliceType_o[0]) {

			case 0: {
				//LOGE("Thread %d, case 20.2", threadID);
				Decode_P_svc(1920 * 1088 / 256,
						SVCinfoList[threadID].decoder_svc_Residu_SPS,
						SVCinfoList[threadID].decoder_svc_Residu_PPS,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o->baseline_vectors,
						SVCinfoList[threadID].decoder_svc_Residu_RefL0,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_quantif,
						SVCinfoList[threadID].decoder_svc_Svc_Vectors_PC_Svc_Vectors,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_px,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_py,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_Upsampling_tmp,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_xk16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_xp16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_yk16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_P_svc_yp16,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefV);
				break;
			}

			case 1: {
				//LOGE("Thread %d, case 20.3", threadID);
				Decode_B_svc(1920 * 1088 / 256,
						SVCinfoList[threadID].decoder_svc_Residu_SPS,
						SVCinfoList[threadID].decoder_svc_Residu_PPS,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o,
						SVCinfoList[threadID].decoder_svc_Residu_RefL0,
						SVCinfoList[threadID].decoder_svc_Residu_RefL1,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_quantif,
						SVCinfoList[threadID].decoder_svc_Svc_Vectors_PC_Svc_Vectors,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_px,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_py,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_Upsampling_tmp,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_xk16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_xp16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_yk16,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_Decode_IPB_svc_Decode_B_svc_yp16,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
						SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
						SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_ResiduBuffer_RefV);
				//LOGE("Thread %d, case 20.3-After", threadID);
				break;
			}

			case 2: {
				//LOGE("Thread %d, case 20.4", threadID);
				Decode_I_svc(1920 * 1088 / 256,
						SVCinfoList[threadID].decoder_svc_Residu_SPS,
						SVCinfoList[threadID].decoder_svc_Residu_PPS,
						SVCinfoList[threadID].decoder_svc_Residu_Slice,
						SVCinfoList[threadID].DqIdNextNal_Nal_o,
						SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
						SVCinfoList[threadID].decoder_svc_Residu_Block,
						SVCinfoList[threadID].decoder_svc_Residu_Residu,
						SVCinfoList[threadID].decoder_svc_slice_main_vector_PC_Main_vector_o->baseline_vectors,
						SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
						SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_quantif,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
						SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV);
				break;
			}
			}

			//LOGE("Thread %d, case 20.5", threadID);
			FinishFrameSVC(1920 * 1088 / 256,
					SVCinfoList[threadID].DqIdNextNal_Nal_o,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_sps_id,
					SVCinfoList[threadID].decoder_svc_Nal_Compute_slice_layer_in_scalable_ext_20_slice_header_21_pps_id,
					SVCinfoList[threadID].decoder_svc_Residu_Current_pic,
					SVCinfoList[threadID].decoder_svc_Residu_Slice,
					SVCinfoList[threadID].decoder_svc_VideoParameter_EndOfSlice[0],
					SVCinfoList[threadID].decoder_svc_Residu_SliceTab,
					SVCinfoList[threadID].decoder_svc_Residu_Block,
					SVCinfoList[threadID].decoder_svc_Residu_Residu,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Mv,
					SVCinfoList[threadID].decoder_svc_MvBuffer_Ref,
					SVCinfoList[threadID].decoder_svc_MvBuffer_1_Ref,
					SVCinfoList[threadID].decoder_svc_VideoParameter_Crop,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay,
					SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o,
					SVCinfoList[threadID].decoder_svc_Residu_Mmo,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
					SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
					SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o,
					SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o);
			//LOGE("Thread %d, case 20.5-After", threadID);

			// if(SVCinfoList[threadID].iFrame%THREAD_NUM!=threadID) break;  // not my job
			// printf("ThreadID = %d A4: frame_num = %d, poc = %d\n",threadID, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->frame_num, SVCinfoList[threadID].decoder_svc_Residu_Current_pic->poc);

			//retrieve
			pthread_mutex_lock(&DirtyMutex); // Bear
			switch (SVCinfoList[threadID].decoder_svc_VideoParameter_ImgToDisplay[0]) {

			case 1: {
				{
					//LOGE("Thread %d, case 20.6", threadID);
					int XDIM
						= ((int *) SVCinfoList[threadID].Display_1_Extract_Image_Y_o)[0]
					    = *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;

					int YDIM
						= ((int *) SVCinfoList[threadID].Display_1_Extract_Image_Y_o)[1]
				        = *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;

					uchar *Y = SVCinfoList[threadID].Display_1_Extract_Image_Y_o + 8;
					uchar *U = Y + (XDIM + 32) * YDIM;
					uchar *V = U + (XDIM + 32) * YDIM / 4;

					LOGE("start extract");
					extract_picture(XDIM, YDIM, 16,
							SVCinfoList[threadID].decoder_svc_VideoParameter_Crop[0],
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
							SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o[0],
							Y, U, V);
					LOGE("end extract");

					//fill data to frame store
					FrameStoreList[threadID].frameWidth = *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;
					FrameStoreList[threadID].frameHeight = *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;
					FrameStoreList[threadID].fillFrame( &FrameStoreList[threadID], Y, U, V);
					LOGE("end fill");
				}
				break;
			}

			case 2: {
				{
					//LOGE("Thread %d, case 20.7", threadID);
					int XDIM
						= ((int *) SVCinfoList[threadID].Display_1_Extract_1_Image_Y_o)[0]
						= *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;

					int YDIM
						= ((int *) SVCinfoList[threadID].Display_1_Extract_1_Image_Y_o)[1]
						= *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;

					uchar *Y = SVCinfoList[threadID].Display_1_Extract_1_Image_Y_o + 8;
					uchar *U = Y + (XDIM + 32) * YDIM;
					uchar *V = U + (XDIM + 32) * YDIM / 4;

					LOGE("start extract");
					extract_picture(XDIM, YDIM, 16,
							SVCinfoList[threadID].decoder_svc_VideoParameter_Crop[0],
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefY,
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefU,
							SVCinfoList[threadID].decoder_svc_PictureBuffer_RefV,
							SVCinfoList[threadID].decoder_svc_VideoParameter_address_pic_o[0],
							Y, U, V);
					LOGE("end extract");

					//fill data to frame store
					FrameStoreList[threadID].frameWidth = *SVCinfoList[threadID].decoder_svc_VideoParameter_xsize_o;
					FrameStoreList[threadID].frameHeight = *SVCinfoList[threadID].decoder_svc_VideoParameter_ysize_o;
					FrameStoreList[threadID].fillFrame( &FrameStoreList[threadID], Y, U, V );
					LOGE("end fill");
				}
				break;
			}
			}

			pthread_mutex_unlock(&DirtyMutex); // Bear

			break;
		}
		}
		//LOGE("Thread %d, Finished one packet", threadID);
	} // end for loop

	LOGE("Thread %d, Finish ALL", threadID);
	return NULL;
}

JNIEXPORT jint JNICALL Java_test_svc_Main_getWidth(JNIEnv * env, jobject obj) {
	if (init)
		return FrameStoreList[CurrentDisplay % THREAD_NUM].frameWidth;
	return 0;
}

JNIEXPORT jint JNICALL Java_test_svc_Main_getHeight(JNIEnv * env, jobject obj) {
	if (init)
		return FrameStoreList[CurrentDisplay % THREAD_NUM].frameHeight;
	return 0;
}

JNIEXPORT void JNICALL Java_test_svc_Main_setFilePath(JNIEnv * env, jobject obj, jstring filePath) {
	FILE_PATH=(char*)(*env)->GetStringUTFChars(env, filePath, NULL);
	fileStreamInit();
}

JNIEXPORT void JNICALL Java_test_svc_Main_setLayerID(JNIEnv * env, jobject obj, jint layerID) {
	LAYER_ID = layerID;
	Layer_changed = 1;
}

JNIEXPORT void JNICALL Java_test_svc_Main_setTemporalID(JNIEnv * env, jobject obj, jint temporalID) {
	TEMPORAL_ID = temporalID;
	Temporal_changed = 1;
}

JNIEXPORT void JNICALL Java_test_svc_Main_setThreadNum(JNIEnv * env, jobject obj, jint threadNum) {
	LOGE("set thread ~");
	THREAD_NUM = threadNum;
}

JNIEXPORT void JNICALL Java_test_svc_Main_clear(JNIEnv * env, jobject obj) {
	LOGE("clear ~");
	pthread_mutex_lock(&DirtyMutex);
	if(init == 0)
	{
		pthread_mutex_unlock(&DirtyMutex);
		return;
	}

	int i;
	free(FrameStoreList);
	free(SVCinfoList);
	free(ThreadList);
	init = 0;
	LOGE("clear done");
	pthread_mutex_unlock(&DirtyMutex);
}

JNIEXPORT jint JNICALL Java_test_svc_Main_decodeSVC(JNIEnv * env, jobject obj, jobjectArray bitmapArray, jint bitmapNum) {
	LOGE("***Start fill");
	//AndroidBitmapInfo info;
	//void* pixels;
	int ret;
	int i, res_and;

	jobject bitmap[64];
	bitmapFilledMax = bitmapNum;

	for (i = 0; i < bitmapNum; ++i) {
		bitmap[i] = (jobject)(*env)->GetObjectArrayElement(env, bitmapArray, i);

		if ((ret = AndroidBitmap_getInfo(env, bitmap[i], &info)) < 0) {
			LOGE("AndroidBitmap_getInfo() failed ! error=%d", ret);
			return;
		}

		if (info.format != ANDROID_BITMAP_FORMAT_RGB_565) {
			LOGE("Bitmap format is not RGB_565 !");
			return;
		}

		pthread_mutex_lock(&DirtyMutex);	// Bear
		if ((ret = AndroidBitmap_lockPixels(env, bitmap[i], &pixels[i])) < 0) {
			LOGE("AndroidBitmap_lockPixels() failed ! error=%d", ret);
		}
		pthread_mutex_unlock(&DirtyMutex);	// Bear
	}

	//__android_log_print(ANDROID_LOG_ERROR,"In","? %d: %d", i, clock());
	if (init == 0) {
		//monstartup("libsvc.so");
		if (android_getCpuFamily() == ANDROID_CPU_FAMILY_ARM && (android_getCpuFeatures() & ANDROID_CPU_ARM_FEATURE_NEON) != 0) {
			// neon
			__android_log_print(ANDROID_LOG_ERROR, "Cpu Info", "with NEON");
		} else {
			// without neon
			__android_log_print(ANDROID_LOG_ERROR, "Cpu Info", "without NEON");
		}

		CurrentDisplay = -1;
		init = 1;

		//init thread data
		ThreadList = (pthread_t*) malloc(sizeof(pthread_t) * THREAD_NUM);
		SVCinfoList = (SVCinfo*) malloc(sizeof(SVCinfo) * THREAD_NUM);
		FrameStoreList = (FrameStore*) malloc(sizeof(FrameStore) * THREAD_NUM);

		time_start = time(NULL);
		framecounter = 0;
		flagError = 0;

		// Bear, increase stack size
		size_t stacksize;
		pthread_attr_init( &attr );
		pthread_attr_getstacksize( &attr, &stacksize );

		LOGE("Default stack size = %li\n", stacksize);
//		__android_log_print(ANDROID_LOG_ERROR, "svc", "Default stack size = %li\n", stacksize);

		stacksize = 1048576;  // 8MB?
		LOGE("Amount of stack needed per thread = %li\n", stacksize);
//		__android_log_print(ANDROID_LOG_ERROR, "svc", "Amount of stack needed per thread = %li\n", stacksize);

		pthread_attr_setstacksize( &attr, stacksize );

		//sem_init(&ReturnSem, 0, 0);

		for (i = 0; i < THREAD_NUM; ++i) {
			FrameStoreConstructor(&FrameStoreList[i]);
			initialize(i);
			pthread_create(&ThreadList[i], &attr, Thread_Decoding, (void*) i);
		}

		LOGE("Finish log");
	} // End init == 0

	//if(CurrentDisplay == 300)
	//	moncleanup();

	bitmapFilledCounter = 0;

	//sem_wait(&ReturnSem);

    pthread_mutex_lock( &FrameBufferMutex );
	while(bitmapFilledCounter == 0)
	{
		if (flagError == 0) {
			pthread_mutex_lock(&CurrentDisplayMutex);	// Lock
			CurrentDisplay++;
			pthread_mutex_unlock(&CurrentDisplayMutex);	// unLock
		}
		else {
			LOGE("Recovery");
			flagError=0;
		}

		LOGE("Wake!!, CurrentDisplay %d", CurrentDisplay);
		pthread_cond_broadcast(&CurrentDisplayCond);
		pthread_cond_wait(&FrameBufferCond, &FrameBufferMutex);
		LOGE("Wait end");
		if(flagError)
			break;
	}
    pthread_mutex_unlock( &FrameBufferMutex );

	LOGE("***End fill, bitmapFilledCounter %d", bitmapFilledCounter);


	if(flagError){
		//error recovery
		return -1;
	}
	return bitmapFilledCounter;
}

